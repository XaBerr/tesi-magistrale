\lvli{QKD software design}
A software repository, or "repo" for short, is a storage location for software packages. Often a table of contents is stored, as well as metadata. Repositories are often one by one with packages. At client side, a package manager helps installing from and updating the repositories. Repositories are the modern way to develop new software.

This chapter starts with a description of the state-of-the-art of the QKD-software, then it describe the solution chosen, and finish with the documentation of the system that implement the solution.

\imgs{0.4}{pictures/git}{Typical scheme of a branch of commits inside a repository.}
\newpage

\lvlii{Memorization, standardization and expansion of the QKD software}
All of the software already developed by the Quantum Future group to control the full QKD system was done temporarily on several computers without a particular organization, and it was therefore necessary to implement an easy system that would allow standardization, memorization, and simplification of code expansion.

To store the code, it was chosen to use GitLab, a web platform that allows the storage and versioning of the code via Git. Git is a free and open-source distributed version control system, it is typically used via shell commands.
The code can then be stored in repositories that are organized in groups.

To create a standardization has been chosen to create a \idx{Boilerplate}, a ready-made code that serves as a template for the realization of various projects.

To simplify code expansion, it was decided to create a CMake-based packet manager and integrate it directly into the Boilerplate. CMake is an open-source, cross-platform family of tools designed to build, test and c++ package software.
This new system allows to list in a file "config.json" the dependencies of every project, that are the libraries necessary for its compilation.
When the project is compiled, dependencies are automatically downloaded and compiled.

\lvlii{Program logical division}
\img{program-logic}{Typical structure of a calculator done with Qt.}
As shown in \fig{program-logic} simple program like a calculator can be divided in two main logical blocks: backend and frontend.
In software design the front end (or frontend) is the part of a software system that manages interaction with the user or with external systems that produce input data (e.g. user interface with a form), the back end (or backend) also called business logic is the part that processes the data generated by the front end. The frontend can be divide in two parts: one that describe the structure, the buttons, the texts of the graphic user interface (GUI); and one that connect each button with the respective business logic function (presentation logic). Sometimes, the presentation logic is used as synonymous of frontend as was done in this thesis.

For example, a calculator application done with Qt libraries is divided as shown in \fig{program-logic}. The business logic doesn't differ from a typical implementation except that the classes used must extend the class QObject. The presentation logic is typically renamed as widget and must extends the class QWidget. The UI is done inside the Qt editor and its information is saved in an xml that has as extension ".ui". In addition, Qt offers a many-to-many callback connection system of the various components called signal-slots.


\lvlii{Boilerplate structure}
\img{repos/boilerplateqt}{BoilerplateQt repository's structure.}
The Boilerplate was built in c++ with the integration of Cmake and Qt.
\idx{CMake} is a system that simplifies the compilation of sources, while \idx{Qt} is a set of libraries that simplify the graphical interface for the c++. The Boilerplate also contains two types of documentation: README and Sphinx.
\idx{README} is a reStructuredText (.rst) file in which a template allows you to quickly describe how to use the library.
The documentation in \idx{Sphinx} is more complex, it uses a python program that collects all the inline comments in the code and provides the class structure visible through web pages.

Typically when an application is developed, the developers decide on an interface (.h) that will have to be visible to other developers and all the rest of the code is kept hidden. This is to simplify the work of other developers who have already filtered the content they are interested in.
To implement this division it was chosen to create an "include" folder that contains the interface and an "src" folder where all the rest of the code will be put.
Moreover, the code is not only composed by features but also by ready-to-use examples, for these examples it was decided to create the folder "apps".
Since not all projects have a GUI, it was chosen to create a separate folder for them "gui" which in case of non-use is easily erasable.
In general the gui folder contains all frontend files, while the "src" and "include" folders contain all the backend files.
For each class made in both backend and frontend, it was chosen to realize unit tests that were put in a separate folder "tests".

All other files and folder are typically left to the exclusive use of the packet manager.
Also during the dependency assembly pipeline, the packet manager compiles individual folders into objects that it will then put together. In particular, it will always compile the folders "src", "include" and eventually "gui", but the folders "apps" and "tests" will be compiled only in case the repository is the parent and not a dependency. This pipeline is controlled by the "CMakeList.txt" files placed in each folder.
Additionally, the "Cmakelist.txt" in the parent folder will extract all dependency information contained in the file "config.json" and then download and compile all dependencies.

\lvlii{Boilerplate documentation}
Boilerplate documentation is stored in a separate repository called \textit{BoilerplateQt.wiki}. It is made in markdown (.md). This section will list its main sections.
  {\parindent0pt
    \input{corpo/boilerplateQtDocs/1-setup-enviroment.tex}
    \input{corpo/boilerplateQtDocs/2-add-source-files.tex}
    \input{corpo/boilerplateQtDocs/3-include-projects.tex}
    \input{corpo/boilerplateQtDocs/4-include-libs.tex}
    \input{corpo/boilerplateQtDocs/5-structure.tex}
    \input{corpo/boilerplateQtDocs/6-git-windows-credential.tex}
  }
